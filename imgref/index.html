<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="In graphics code it’s very common to pass `width` and `height` along with a `Vec` of pixels, all as separate arguments. This is tedious, and can lead to errors."><title>imgref - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-492a78a4a87dcc01.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="imgref" data-themes="" data-resource-suffix="" data-rustdoc-version="1.82.0 (f6e511eec 2024-10-15)" data-channel="1.82.0" data-search-js="search-a99f1315e7cc5121.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-921df33f47b8780c.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-3b12f09e550e0385.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../imgref/index.html">imgref</a><span class="version">1.11.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#traits">Traits</a></li><li><a href="#types">Type Aliases</a></li></ul></section></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">imgref</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../src/imgref/lib.rs.html#1-930">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>In graphics code it’s very common to pass <code>width</code> and <code>height</code> along with a <code>Vec</code> of pixels,
all as separate arguments. This is tedious, and can lead to errors.</p>
<p>This crate is a simple struct that adds dimensions to the underlying buffer. This makes it easier to correctly keep track
of the image size and allows passing images with just one function argument instead three or four.</p>
<p>Additionally, it has a concept of a <code>stride</code>, which allows defining sub-regions of images without copying,
as well as handling padding (e.g. buffers for video frames may require to be a multiple of 8, regardless of logical image size).</p>
<p>For convenience, there are iterators over rows or all pixels of a (sub)image and
pixel-based indexing directly with <code>img[(x,y)]</code> (where <code>x</code>/<code>y</code> can be <code>u32</code> as well as <code>usize</code>).</p>
<p><code>Img&lt;Container&gt;</code> type has aliases for common uses:</p>
<ul>
<li>Owned: <code>ImgVec&lt;T&gt;</code> → <code>Img&lt;Vec&lt;T&gt;&gt;</code>  (use it in <code>struct</code>s and return types)</li>
<li>Reference: <code>ImgRef&lt;T&gt;</code> → <code>Img&lt;&amp;[T]&gt;</code> (use it in function arguments)</li>
<li>Mutable reference: <code>ImgRefMut&lt;T&gt;</code> → <code>Img&lt;&amp;mut [T]&gt;</code></li>
</ul>
<p>It is assumed that the container is <a href="https://crates.io/crates/rgb/">one element per pixel</a>, e.g. <code>Vec&lt;RGBA&gt;</code>,
and <em>not</em> a <code>Vec&lt;u8&gt;</code> where 4 <code>u8</code> elements are interpreted as one pixel.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>imgref::<span class="kw-2">*</span>;

<span class="kw">fn </span>main() {
    <span class="kw">let </span>img = Img::new(<span class="macro">vec!</span>[<span class="number">0</span>; <span class="number">1000</span>], <span class="number">50</span>, <span class="number">20</span>); <span class="comment">// 1000 pixels of a 50×20 image

    </span><span class="kw">let </span>new_image = some_image_processing_function(img.as_ref()); <span class="comment">// Use imgvec.as_ref() instead of &amp;imgvec for better efficiency

    </span><span class="macro">println!</span>(<span class="string">"New size is {}×{}"</span>, new_image.width(), new_image.height());
    <span class="macro">println!</span>(<span class="string">"And the top left pixel is {:?}"</span>, new_image[(<span class="number">0u32</span>,<span class="number">0u32</span>)]);

    <span class="kw">let </span>first_row_slice = <span class="kw-2">&amp;</span>new_image[<span class="number">0</span>];

    <span class="kw">for </span>row <span class="kw">in </span>new_image.rows() {
        <span class="comment">// …
    </span>}
    <span class="kw">for </span>px <span class="kw">in </span>new_image.pixels() {
        <span class="comment">// …
    </span>}

    <span class="comment">// slice (x, y, width, height) by reference - no copy!
    </span><span class="kw">let </span>fragment = img.sub_image(<span class="number">5</span>, <span class="number">5</span>, <span class="number">15</span>, <span class="number">15</span>);

    <span class="comment">//
    </span><span class="kw">let </span>(vec, width, height) = fragment.to_contiguous_buf();
}</code></pre></div>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.Img.html" title="struct imgref::Img">Img</a></div><div class="desc docblock-short">Basic struct used for both owned (alias <code>ImgVec</code>) and borrowed (alias <code>ImgRef</code>) image fragments.</div></li><li><div class="item-name"><a class="struct" href="struct.PixelsIter.html" title="struct imgref::PixelsIter">Pixels<wbr>Iter</a></div><div class="desc docblock-short">Iterates over pixels in the (sub)image. Call <code>Img.pixels()</code> to create it.</div></li><li><div class="item-name"><a class="struct" href="struct.PixelsIterMut.html" title="struct imgref::PixelsIterMut">Pixels<wbr>Iter<wbr>Mut</a></div><div class="desc docblock-short">Iterates over pixels in the (sub)image. Call <code>Img.pixels_mut()</code> to create it.</div></li><li><div class="item-name"><a class="struct" href="struct.PixelsRefIter.html" title="struct imgref::PixelsRefIter">Pixels<wbr>RefIter</a></div><div class="desc docblock-short">Iterates over pixels in the (sub)image. Call <code>Img.pixels_ref()</code> to create it.</div></li><li><div class="item-name"><a class="struct" href="struct.RowsIter.html" title="struct imgref::RowsIter">Rows<wbr>Iter</a></div><div class="desc docblock-short">Rows of the image. Call <code>Img.rows()</code> to create it.</div></li><li><div class="item-name"><a class="struct" href="struct.RowsIterMut.html" title="struct imgref::RowsIterMut">Rows<wbr>Iter<wbr>Mut</a></div><div class="desc docblock-short">Rows of the image. Call <code>Img.rows_mut()</code> to create it.</div></li></ul><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.ImgExt.html" title="trait imgref::ImgExt">ImgExt</a></div><div class="desc docblock-short">Additional methods that depend on buffer size</div></li><li><div class="item-name"><a class="trait" href="trait.ImgExtMut.html" title="trait imgref::ImgExtMut">ImgExt<wbr>Mut</a></div><div class="desc docblock-short">Additional methods that depend on buffer size</div></li></ul><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.ImgRef.html" title="type imgref::ImgRef">ImgRef</a></div><div class="desc docblock-short">Reference to pixels inside another image.
Pass this structure by value (i.e. <code>ImgRef</code>, not <code>&amp;ImgRef</code>).</div></li><li><div class="item-name"><a class="type" href="type.ImgRefMut.html" title="type imgref::ImgRefMut">ImgRef<wbr>Mut</a></div><div class="desc docblock-short">Same as <code>ImgRef</code>, but mutable
Pass this structure by value (i.e. <code>ImgRef</code>, not <code>&amp;ImgRef</code>).</div></li><li><div class="item-name"><a class="type" href="type.ImgVec.html" title="type imgref::ImgVec">ImgVec</a></div><div class="desc docblock-short">Image owning its pixels.</div></li></ul></section></div></main></body></html>