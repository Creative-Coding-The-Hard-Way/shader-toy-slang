<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Traits and helpers for bitstream handling functionality"><title>bitstream_io - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-492a78a4a87dcc01.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="bitstream_io" data-themes="" data-resource-suffix="" data-rustdoc-version="1.82.0 (f6e511eec 2024-10-15)" data-channel="1.82.0" data-search-js="search-a99f1315e7cc5121.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-921df33f47b8780c.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-3b12f09e550e0385.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../bitstream_io/index.html">bitstream_<wbr>io</a><span class="version">2.6.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#reexports">Re-exports</a></li><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#traits">Traits</a></li><li><a href="#types">Type Aliases</a></li></ul></section></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">bitstream_io</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../src/bitstream_io/lib.rs.html#9-1029">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Traits and helpers for bitstream handling functionality</p>
<p>Bitstream readers are for reading signed and unsigned integer
values from a stream whose sizes may not be whole bytes.
Bitstream writers are for writing signed and unsigned integer
values to a stream, also potentially un-aligned at a whole byte.</p>
<p>Both big-endian and little-endian streams are supported.</p>
<p>The only requirement for wrapped reader streams is that they must
implement the <code>Read</code> trait, and the only requirement
for writer streams is that they must implement the <code>Write</code> trait.</p>
<p>In addition, reader streams do not consume any more bytes
from the underlying reader than necessary, buffering only a
single partial byte as needed.
Writer streams also write out all whole bytes as they are accumulated.</p>
<p>Readers and writers are also designed to work with integer
types of any possible size.
Many of Rust’s built-in integer types are supported by default.</p>
<h2 id="minimum-compiler-version"><a class="doc-anchor" href="#minimum-compiler-version">§</a>Minimum Compiler Version</h2>
<p>Beginning with version 2.4, the minimum compiler version has been
updated to Rust 1.79.</p>
<p>The issue is that reading an excessive number of
bits to a type which is too small to hold them,
or writing an excessive number of bits from too small of a type,
are always errors:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::io::{Read, Cursor};
<span class="kw">use </span>bitstream_io::{BigEndian, BitReader, BitRead};
<span class="kw">let </span>data = [<span class="number">0</span>; <span class="number">10</span>];
<span class="kw">let </span><span class="kw-2">mut </span>r = BitReader::endian(Cursor::new(<span class="kw-2">&amp;</span>data), BigEndian);
<span class="kw">let </span>x: <span class="prelude-ty">Result</span>&lt;u32, <span class="kw">_</span>&gt; = r.read(<span class="number">64</span>);  <span class="comment">// reading 64 bits to u32 always fails at runtime
</span><span class="macro">assert!</span>(x.is_err());</code></pre></div>
<p>but those errors will not be caught until the program runs,
which is less than ideal for the common case in which
the number of bits is already known at compile-time.</p>
<p>But starting with Rust 1.79, we can now have read and write methods
which take a constant number of bits and can validate the number of bits
are small enough for the type being read/written at compile-time:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::io::{Read, Cursor};
<span class="kw">use </span>bitstream_io::{BigEndian, BitReader, BitRead};
<span class="kw">let </span>data = [<span class="number">0</span>; <span class="number">10</span>];
<span class="kw">let </span><span class="kw-2">mut </span>r = BitReader::endian(Cursor::new(<span class="kw-2">&amp;</span>data), BigEndian);
<span class="kw">let </span>x: <span class="prelude-ty">Result</span>&lt;u32, <span class="kw">_</span>&gt; = r.read_in::&lt;<span class="number">64</span>, <span class="kw">_</span>&gt;();  <span class="comment">// doesn't compile at all</span></code></pre></div>
<p>Since catching potential bugs at compile-time is preferable
to encountering errors at runtime, this will hopefully be
an improvement in the long run.</p>
<h2 id="migrating-from-pre-100"><a class="doc-anchor" href="#migrating-from-pre-100">§</a>Migrating From Pre 1.0.0</h2>
<p>There are now <code>BitRead</code> and <code>BitWrite</code> traits for bitstream
reading and writing (analogous to the standard library’s
<code>Read</code> and <code>Write</code> traits) which you will also need to import.
The upside to this approach is that library consumers
can now make functions and methods generic over any sort
of bit reader or bit writer, regardless of the underlying
stream byte source or endianness.</p>
</div></details><h2 id="reexports" class="section-header">Re-exports<a href="#reexports" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name" id="reexport.BitRead"><code>pub use read::<a class="trait" href="read/trait.BitRead.html" title="trait bitstream_io::read::BitRead">BitRead</a>;</code></div></li><li><div class="item-name" id="reexport.BitReader"><code>pub use read::<a class="struct" href="read/struct.BitReader.html" title="struct bitstream_io::read::BitReader">BitReader</a>;</code></div></li><li><div class="item-name" id="reexport.ByteRead"><code>pub use read::<a class="trait" href="read/trait.ByteRead.html" title="trait bitstream_io::read::ByteRead">ByteRead</a>;</code></div></li><li><div class="item-name" id="reexport.ByteReader"><code>pub use read::<a class="struct" href="read/struct.ByteReader.html" title="struct bitstream_io::read::ByteReader">ByteReader</a>;</code></div></li><li><div class="item-name" id="reexport.FromBitStream"><code>pub use read::<a class="trait" href="read/trait.FromBitStream.html" title="trait bitstream_io::read::FromBitStream">FromBitStream</a>;</code></div></li><li><div class="item-name" id="reexport.FromBitStreamWith"><code>pub use read::<a class="trait" href="read/trait.FromBitStreamWith.html" title="trait bitstream_io::read::FromBitStreamWith">FromBitStreamWith</a>;</code></div></li><li><div class="item-name" id="reexport.FromByteStream"><code>pub use read::<a class="trait" href="read/trait.FromByteStream.html" title="trait bitstream_io::read::FromByteStream">FromByteStream</a>;</code></div></li><li><div class="item-name" id="reexport.FromByteStreamWith"><code>pub use read::<a class="trait" href="read/trait.FromByteStreamWith.html" title="trait bitstream_io::read::FromByteStreamWith">FromByteStreamWith</a>;</code></div></li><li><div class="item-name" id="reexport.HuffmanRead"><code>pub use read::<a class="trait" href="read/trait.HuffmanRead.html" title="trait bitstream_io::read::HuffmanRead">HuffmanRead</a>;</code></div></li><li><div class="item-name" id="reexport.BitCounter"><code>pub use write::<a class="struct" href="write/struct.BitCounter.html" title="struct bitstream_io::write::BitCounter">BitCounter</a>;</code></div></li><li><div class="item-name" id="reexport.BitRecorder"><code>pub use write::<a class="struct" href="write/struct.BitRecorder.html" title="struct bitstream_io::write::BitRecorder">BitRecorder</a>;</code></div></li><li><div class="item-name" id="reexport.BitWrite"><code>pub use write::<a class="trait" href="write/trait.BitWrite.html" title="trait bitstream_io::write::BitWrite">BitWrite</a>;</code></div></li><li><div class="item-name" id="reexport.BitWriter"><code>pub use write::<a class="struct" href="write/struct.BitWriter.html" title="struct bitstream_io::write::BitWriter">BitWriter</a>;</code></div></li><li><div class="item-name" id="reexport.ByteWrite"><code>pub use write::<a class="trait" href="write/trait.ByteWrite.html" title="trait bitstream_io::write::ByteWrite">ByteWrite</a>;</code></div></li><li><div class="item-name" id="reexport.ByteWriter"><code>pub use write::<a class="struct" href="write/struct.ByteWriter.html" title="struct bitstream_io::write::ByteWriter">ByteWriter</a>;</code></div></li><li><div class="item-name" id="reexport.HuffmanWrite"><code>pub use write::<a class="trait" href="write/trait.HuffmanWrite.html" title="trait bitstream_io::write::HuffmanWrite">HuffmanWrite</a>;</code></div></li><li><div class="item-name" id="reexport.ToBitStream"><code>pub use write::<a class="trait" href="write/trait.ToBitStream.html" title="trait bitstream_io::write::ToBitStream">ToBitStream</a>;</code></div></li><li><div class="item-name" id="reexport.ToBitStreamWith"><code>pub use write::<a class="trait" href="write/trait.ToBitStreamWith.html" title="trait bitstream_io::write::ToBitStreamWith">ToBitStreamWith</a>;</code></div></li><li><div class="item-name" id="reexport.ToByteStream"><code>pub use write::<a class="trait" href="write/trait.ToByteStream.html" title="trait bitstream_io::write::ToByteStream">ToByteStream</a>;</code></div></li><li><div class="item-name" id="reexport.ToByteStreamWith"><code>pub use write::<a class="trait" href="write/trait.ToByteStreamWith.html" title="trait bitstream_io::write::ToByteStreamWith">ToByteStreamWith</a>;</code></div></li></ul><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="huffman/index.html" title="mod bitstream_io::huffman">huffman</a></div><div class="desc docblock-short">Traits and implementations for reading or writing Huffman codes
from or to a stream.</div></li><li><div class="item-name"><a class="mod" href="read/index.html" title="mod bitstream_io::read">read</a></div><div class="desc docblock-short">Traits and implementations for reading bits from a stream.</div></li><li><div class="item-name"><a class="mod" href="write/index.html" title="mod bitstream_io::write">write</a></div><div class="desc docblock-short">Traits and implementations for writing bits to a stream.</div></li></ul><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.BigEndian.html" title="struct bitstream_io::BigEndian">BigEndian</a></div><div class="desc docblock-short">Big-endian, or most significant bits first</div></li><li><div class="item-name"><a class="struct" href="struct.BitQueue.html" title="struct bitstream_io::BitQueue">BitQueue</a></div><div class="desc docblock-short">A queue for efficiently pushing bits onto a value
and popping them off a value.</div></li><li><div class="item-name"><a class="struct" href="struct.LittleEndian.html" title="struct bitstream_io::LittleEndian">Little<wbr>Endian</a></div><div class="desc docblock-short">Little-endian, or least significant bits first</div></li></ul><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.Endianness.html" title="trait bitstream_io::Endianness">Endianness</a></div><div class="desc docblock-short">A stream’s endianness, or byte order, for determining
how bits should be read.</div></li><li><div class="item-name"><a class="trait" href="trait.Numeric.html" title="trait bitstream_io::Numeric">Numeric</a></div><div class="desc docblock-short">This trait extends many common integer types (both unsigned and signed)
with a few trivial methods so that they can be used
with the bitstream handling traits.</div></li><li><div class="item-name"><a class="trait" href="trait.Primitive.html" title="trait bitstream_io::Primitive">Primitive</a></div><div class="desc docblock-short">A trait intended for simple fixed-length primitives (such as ints and floats)
which allows them to be read and written to streams of
different endiannesses verbatim.</div></li><li><div class="item-name"><a class="trait" href="trait.SignedNumeric.html" title="trait bitstream_io::SignedNumeric">Signed<wbr>Numeric</a></div><div class="desc docblock-short">This trait extends many common signed integer types
so that they can be used with the bitstream handling traits.</div></li></ul><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.BE.html" title="type bitstream_io::BE">BE</a></div><div class="desc docblock-short">Big-endian, or most significant bits first</div></li><li><div class="item-name"><a class="type" href="type.LE.html" title="type bitstream_io::LE">LE</a></div><div class="desc docblock-short">Little-endian, or least significant bits first</div></li></ul></section></div></main></body></html>