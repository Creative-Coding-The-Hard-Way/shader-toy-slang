searchState.loadedDescShard("imgref", 0, "In graphics code it’s very common to pass <code>width</code> and …\nBasic struct used for both owned (alias <code>ImgVec</code>) and …\nAdditional methods that depend on buffer size\nAdditional methods that depend on buffer size\nReference to pixels inside another image. Pass this …\nSame as <code>ImgRef</code>, but mutable Pass this structure by value …\nImage owning its pixels.\nIterates over pixels in the (sub)image. Call <code>Img.pixels()</code> …\nIterates over pixels in the (sub)image. Call …\nIterates over pixels in the (sub)image. Call …\nRows of the image. Call <code>Img.rows()</code> to create it.\nRows of the image. Call <code>Img.rows_mut()</code> to create it.\nReturns a reference to the buffer, width, height. …\nBorrow the container mutably\nMake a mutable reference to the entire image\nMake a mutable reference to the entire image\nBorrow the container\nMake a reference to this image to pass it to functions …\nMake mutable reference immutable\nMake mutable reference immutable\nMake a reference to this image to pass it to functions …\nImmutable reference to the pixel storage. Warning: exposes …\nStorage for the pixels. Usually <code>Vec&lt;Pixel&gt;</code> or <code>&amp;[Pixel]</code>. …\nStorage for the pixels. Usually <code>Vec&lt;Pixel&gt;</code> or <code>&amp;[Pixel]</code>. …\nStorage for the pixels. Usually <code>Vec&lt;Pixel&gt;</code> or <code>&amp;[Pixel]</code>. …\nStorage for the pixels. Usually <code>Vec&lt;Pixel&gt;</code> or <code>&amp;[Pixel]</code>. …\nMutable reference to the pixel storage. Warning: exposes …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nHeight of the image in pixels.\nHeight of the image in pixels.\nHeight of the image in pixels.\nHeight of the image in pixels.\nHeight of the image in pixels.\nHeight in number of full strides. If the underlying buffer …\nTake n-th row as a slice. Same as <code>.rows().nth(n).unwrap()</code>\nRead a pixel at <code>(x,y)</code> location (e.g. px = <code>img[(x,y)]</code>)\nRead a pixel at <code>(x,y)</code> location (e.g. px = <code>img[(x,y)]</code>)\nRead a pixel at <code>(x,y)</code> location (e.g. px = <code>img[(x,y)]</code>)\nTake n-th row as a slice. Same as <code>.rows().nth(n).unwrap()</code>\nRead a pixel at <code>(x,y)</code> location (e.g. px = <code>img[(x,y)]</code>)\nRead a pixel at <code>(x,y)</code> location (e.g. px = <code>img[(x,y)]</code>)\nTake n-th row as a slice. Same as <code>.rows().nth(n).unwrap()</code>\nRead a pixel at <code>(x,y)</code> location (e.g. px = <code>img[(x,y)]</code>)\nTake n-th row as a mutable slice. Same as …\nWrite a pixel at <code>(x,y)</code> location (e.g. <code>img[(x,y)] = px</code>)\nTake n-th row as a mutable slice. Same as …\nWrite a pixel at <code>(x,y)</code> location (e.g. <code>img[(x,y)] = px</code>)\nWrite a pixel at <code>(x,y)</code> location (e.g. <code>img[(x,y)] = px</code>)\nWrite a pixel at <code>(x,y)</code> location (e.g. <code>img[(x,y)] = px</code>)\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet the pixel storage by consuming the image. Be careful …\nReturns the buffer, width, height. Guarantees that the …\nDeprecated. Use .<code>rows()</code> or .<code>pixels()</code> iterators which are …\nConvert underlying buffer to owned (e.g. slice to vec)\nA convenience method for creating an image of the same …\nCreate new image with <code>Container</code> (which can be <code>Vec</code>, <code>&amp;[]</code> or …\nA convenience method for creating an image of the same …\nSame as <code>new()</code>, except each row is located <code>stride</code> number of …\nIf you want to iterate in parallel, parallelize <code>rows()</code> …\nIterate <code>width*height</code> pixels in the <code>Img</code>, ignoring padding …\nPanics\nIterate <code>width*height</code> pixels in the <code>Img</code>, ignoring padding …\nIf you want to iterate in parallel, parallelize <code>rows()</code> …\nPanics\nIf you want to iterate in parallel, parallelize <code>rows()</code> …\nIf you want to iterate in parallel, parallelize <code>rows()</code> …\nIf you want to iterate in parallel, parallelize <code>rows()</code> …\nIf you want to iterate in parallel, parallelize <code>rows()</code> …\nIterate <code>width*height</code> pixels in the <code>Img</code>, by reference, …\nIterate <code>width*height</code> pixels in the <code>Img</code>, by reference, …\nIterate over rows of the image as slices\nIterate over whole rows of pixels as slices\nIterate over whole rows as slices\nIterate over whole rows as slices\nIterate over rows of the image as slices\nIterate over whole rows of pixels as slices\nIterate over rows of the image as mutable slices\nIterate over whole rows as slices\nIterate over whole rows as slices\nIterate over rows of the image as mutable slices\nIterate over the entire buffer as rows, including all …\nIterate over the entire buffer as rows, including all …\nIterate over the entire buffer as rows, including all …\nIterate over the entire buffer as rows, including all …\nNumber of <em>pixels</em> to skip in the container to advance to …\nNumber of pixels to skip in the container to advance to …\nNumber of pixels to skip in the container to advance to …\nNumber of pixels to skip in the container to advance to …\nNumber of pixels to skip in the container to advance to …\nMake a reference for a part of the image, without copying …\nMake a reference for a part of the image, without copying …\nTurn this into immutable reference, and slice a subregion …\nMake a reference for a part of the image, without copying …\nTurn this into immutable reference, and slice a subregion …\nMake a reference for a part of the image, without copying …\nCreate a mutable view into a region within the image. See …\nTrim this image without copying. Note that mutable borrows …\nTrim this image without copying. Note that mutable borrows …\nCreate a mutable view into a region within the image. See …\nReturns a reference to the buffer, width, height. …\nReturns a reference to the buffer, width, height. …\nConvert underlying buffer to owned (e.g. slice to vec)\nWidth of the image in pixels.\nWidth of the image in pixels.\nWidth of the image in pixels.\nWidth of the image in pixels.\nWidth of the image in pixels.\nMaximum possible width of the data, including the stride.")